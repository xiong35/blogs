
# 《精通python设计模式》读书笔记

# SOLID原则

|     |                                     |              |
| --- | ----------------------------------- | ------------ |
| SRP | The Single Responsibility Principle | 单一责任原则 |
| OCP | The Open Closed Principle           | 开放封闭原则 |
| LSP | The Liskov Substitution Principle   | 里氏替换原则 |
| ISP | The Interface Segregation Principle | 接口分离原则 |
| DIP | The Dependency Inversion Principle  | 依赖倒置原则 |

---

## 工厂模式（Factory）

客户端请求一个对象（而不是自己实例化对象），而无需知道这个对象是谁生成的

### 工厂方法

执行单个函数，他接受一个参数来指明我们需要什么，由工厂方法来处理所有细节  

适用条件：创建对象的代码散落在不同的地方，难以跟踪他们的情形  
一般会根据对象种类分组，创建多个工厂方法  

### 抽象工厂

是一组工厂方法，每个方法产生不同种的对象，但是这一组方法具有相似性，会放在一起用  

---

## 建造者模式（Builder）

当一个对象需要多个步骤来创造，并且要求可以自定义构造过程时就可以用建造者模式  
如：创建html时，body, head 等部分都要一步一步单独创造  

组成成分：

- Builder：内置一系列统一接口的方法，用来个性化的创造一个对象
- Director：接受参数来指派builder创造对象

> 对比工厂模式：建造者模式适合创造复杂对象

---

## 原型模式（prototype）

当我们已有一个对象，并想创建他的一个副本的时候使用原型模式
一般用```copy.deepcopy()```方法复制，再用```\_\_dict\_\_.update(**kwargs)微调  

---

## 适配器模式（Adapter）

一个额外的代码层，能让两个接口通信  
常用字典储存{通用接口：特殊方法}来实现  

---

## 修饰器模式（Decorator）

能在不影响原有功能的情况下添加功能  

修饰器中定义一个修饰函数  
修饰器接受一个函数作为参数，返回包装过的**函数**  

e.g. ：定义一个包装递推数列，增加储存功能的修饰器

    def memoize(fn):
        known = dict()

        @functools.wraps(fn)
        def memoizer(*args):
            if args not in known:
                known[args] = fn(*args)
            return known[args]
            
        return memoizer

其中```@functools.wraps(fn)```的作用是保证包装后函数的名字等信息不改变，一般包装时都会加上这一句，不加也无太大妨碍  

---

## 外观模式（Facade）

封装内部的复杂操作，仅留下简单的接口给外界  

---

## 享元模式（Flyweight）

为相似的对象引入数据共享  
例如游戏中初始化无数棵树是不现实的，可以让他们共享绝大多数数据  

一个享元就是一个不可变的数据共享对象，可变数据不应该放到享元里  

通常做法：修改\_\_new\_\_方法，在实例化对象前检查是已经存在，有点类似上文的memory修饰器  

---

## 模型\-视图\-控制器模式（Model\-View\-Controller）

模型处理数据，通过控制器和视图交互  

模型很智能：

- 包含校验/业务规则/逻辑
- 处理应用的状态
- 访问应用数据
- 不依赖UI

控制器很瘦：

- 在用户和视图交互时更新模型
- 模型改变时更新视图
- 如有需要，预处理数据
- 不展示数据
- 不含逻辑，不含校验

视图很傻瓜：

- 展示数据
- 和用户交互
- 仅做最简单的数据处理
- 不储存/校验/运算

---

## 代理模式（Proxy）

在访问某个对象前执行一些重要操作（如检查权限，计数等）可使用代理模式，将对对象的访问转移为对代理者的访问  

也用来进行懒初始化  
python中常用修饰器实现，将暂时不初始化的变量先设成None，在调用的时候在初始化  

TODO：  

- abc模块可禁止直接实例化对象？
- 如何安全地存储密码？

---

## 责任链模式（Chain of Responsibility）

对于我们不知道哪个方法来处理某个请求时（如计网中的广播），规定以下方案：  
当前结点只做以下操作：  

- 决定是否处理这个请求
- 将请求转发给下家

可用树/链表等实现  

解耦了用户和程序，用户和程序不再需要多对多的连接，只用留下链的一头在外部即可  

例如在几个被选的类中增加自己的处理方法，若不能处理就转发给下家  

---

## 命令模式（Command）

封装一些命令为函数/类，例如撤销，删除，复制粘贴  

---

## 解释器模式（Interpreter）

封装所有细节，仅留下一种自编的处理语言给外界，让不怎么懂的人利用这种新语言操作  

可以用Pyparsing库来解析  

---

## 观察者模式（Observer）

订阅者追随某一个信息源，每当信息源更新都会把内容发给所有观察者  

理解：拍卖会上主持人接受来自订阅者的信息，并将更新过的内容发送给订阅者  

可使用@setter修饰，每当值改变就通知注册表里的所有观察者  

---

## 状态模式（State）

用来描述一系列的状态转换  

直接```import state_machine```即可  

---

## 策略模式（Strategy）

根据要处理的对象属性/数量，选择不同的算法解决问题
