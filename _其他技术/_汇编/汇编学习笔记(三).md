
# 汇编学习笔记(三)

## 内中断

### 基本知识

优先级: 除法, 溢出等软件中断 > 不可屏蔽中断 > 可屏蔽中断 > 单步中断

**中断向量表**: 通过 8 位的中断类型码, 在向量表中查找中断处理程序对应的段地址和偏移地址, **存放在内存0处**(0~1024)

过程:

1. 从中断信息中获取中断类型码
2. 标志寄存器的值入栈
3. 设置标志寄存器 tf if 为 0
4. cs 入栈
5. ip 入栈
6. 设置cs:ip为中断处理程序对应的值

cpu 执行完一条指令后检测 tf, 如果 tf==1 则产生单步中断  

### int / iret

用法: `int <中断类型码>`

`iret`: 比普通的 ret 多了一步恢复标志寄存器, 和 int 配合使用

> 补: `mov ax, offset <标号a> - offset <标号b>` 可以获得一段代码的长度, 配合 movsb 可以设置中断处理程序

### bios

1. cpu 启动时 cs = 0ffffh, ip = 0, ffff:0处有一个跳转指令, 执行 bios 中的硬件检查和初始化程序
2. 初始化程序将 bios 提供的中断例程的入口地址分别登记在向量表里
3. 调用 `int 19h`, 进行操作系统的引导, 将控制权交给系统

bios 和 dos 提供的中断例程都是用 ah 存放内部子程序的标号

## 端口

- `in` 
  - `in al 60h` => 从 60h 号端口读取一个字节数据送入 al  
  - `mov dx, 1111h; in al, dx` => 16位端口必须用到dx
`out`
  - `out 21h, al` => 将 al 中的数据存入 21h 号端口 
  - `mov dx, 1111h; out dx, al` => 向16位端口里输入数据

> 只能使用 ax / al  
> 0~255端口用 al 就可以读写, 256~65535是16位, 用ax  
> 端口的数据都是一个字节的?  
> cpu 将设备内部的寄存器当作端口使用

## 外中断

由接口设备产生的中断

当 cpu 检测到可屏蔽中断(外中断)时, 如果 if=1 则必须响应中断, 否则不响应.  
`sti`: 设置 if 为1, `cli`: 设置 if 为0  

# TODO: 键盘输入

我不学了QAQ汇编这玩意太扯了