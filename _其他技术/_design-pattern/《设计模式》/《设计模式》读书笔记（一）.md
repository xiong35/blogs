# 《设计模式》读书笔记(一)

> 关键词: 设计模式, 读书笔记

## 策略模式

### 场景

从家到学校有 _坐公交, 坐地铁, 步行, 坐直升机_ 4 种方式, 每个学生会使用不同的方式去学校. 如果在学生类里定义 `goToSchool` 方法, 会使每个学生都要分别重载或者实现这个方法, 使代码变得复杂. 而如果将 `goToScool` 抽成接口, 每个学生也得各自实现接口, 同样复杂

有没有办法能让学生对象只用**选择**这几种上学方法之一呢?

当然, 可以实现一个函数, 这个函数接受**上学方法**的参数, 根据参数执行不同的方法. 这样固然可以满足需求, 但是这不是面向对象的做法, 不能保证实现的规范统一, 难以维护. 此外还需要额外的条件判断.

使用策略模式就可以解决这个问题!

### 模式

创建 `GoToSCoolBehavior` 接口, 其中包含 `go()` 方法.  
分别实现 4 种接口, 记为`ByFoot, ByBus...`  
让学生类**有一个** `GoToSCoolBehavior` 的接口的实例, 记为`goToSCoolBehavior`  
在实例化学生时, 只需要指定 `goToSCoolBehavior = new ByFoot()`  
调用的时候, 使用`goToSCoolBehavior.go()`即可, 因为`Byxxx`都是`GoToSCoolBehavior`的实例, 一定实现了``go()`方法, 可放心的调用

这样做的好处在于

1. 可自由切换方法
2. 扩展性, 可维护性好
3. 避免了条件判断

## 观察者模式

### 场景

你订阅了 Steam 的邮箱, 是不是每次游戏打折他就会给你发邮件让你去买买买?  
这里用到的就是观察者模式.

你的目的是第一时间收到游戏打折的通知(数据变动的通知)  
Steam 的目的是第一时间告诉你打折的消息(数据变动这件事), 为了高效的完成这个操作, 他会维护一个订阅者的数据表. 每当价格变化, 他就会一一向订阅用户发送邮件(价格变动的通知). 每当有用户注册订阅/退订, 只需要在表里添加/删除用户即可

总结一下, Steam 类有三个主要的方法

1. addObserver: 向用户表添加用户
2. delObserver: 从用户表删除用户
3. notify: 通知所有用户表中的用户降价消息

### 细节部分

除了用户, Steam 可能还要通知别的观察者(比如说广告商), 为了统一观测者们, Steam 要求观测者必须 implement 一个 Observer 接口, 实现其中的 update 方法, 在这里可以规定接收数据的格式, 如规定 `update( oldPrice: float, newPrice: float)` 等  
这样的话, 每当数据发生更新, 只需要依次调用列表里所有对象的`update`方法即可

此外, 为了方便订阅及退订, 每个 Observer 还需要拥有一份他们所订阅的主体的引用(你可以理解为订阅者需要知道 steam 的官网网址, 你在那里才能订阅/退订)

## 装饰者模式

可以将装饰器理解为装备, 他有以下的性质

1. 装备了他之后会获得额外的加成(实现了额外的功能)
2. 可以同时拥有很多装备(包装无数的装饰器)
3. 使用装备非常简单, 且不会互相影响(装饰器的使用方便且独立)
4. 某些装备只有特定职业可以使用(使用装饰器有一定限制)

**我们举个比方**(以 py 为例):

实现斐波那契数列求和的功能, 你很快的写下了这样的代码:

```python
def fib(n):
    if n <= 2:
        return n
    return fib(n-1) + fib(n-2)
```

然后你输入了一个 fib(100), 好的, 程序卡死了/扶额

你想优化这个函数, 但是又不想抛弃你刚刚辛辛苦苦写下的 4 行代码, 于是你想到了这样写:

```python
def memoize(fn):
    known = dict()

    def memoizer(*args):
        if args not in known:
            known[args] = fn(*args)
        return known[args]

    return memoizer

@memoize
def fib(n):
    if n <= 2:
        return n
    return fib(n-1) + fib(n-2)
```

别慌, 我们一点点看  
首先, 这个`memoize`吃一个函数, 吐一个函数, 对吧

返回的函数有什么特点呢? 他是一个偷懒的函数, 当调用他的时候他第一时间想的不是动脑子计算, 而是翻自己的笔记, 看有没有算过这个东西, 实在找不到笔记了他才勉强去算一算. 不过他也是个勤奋的函数, 每次算完之后都会拿小本本记下题目和答案(好吧, 其实只是为了方便下次白 piao 罢了...)

那么返回的这个函数怎么用呢? 这里我先简单讲一下 python 的@语法

```python
@g
def f(x):
    pass
f("x") # 装饰后的 f(x)
# ↑等价于↓
g(f)("x") # g函数以f这个函数为参数, 返回一个函数, 这个函数的参数和原来的f一模一样, 简直就是...f(x)的升级版!
```

对, 就是升级版. 装饰后的函数和原来的函数本质类似, 但是功能却更高级, 这也和我开头处游戏装备的比喻吻合

你会说这样写一堆装饰器的代码还不如改改原来的函数呢!  
没错, 现在项目小, 你大可这么做, 但是想想, 如果以后参与大项目, 代码依赖关系复杂, 你随便改动代码可能牵一发而动全身, 最后把项目搞砸了都有可能. 理想的发难是什么呢, 是在保留原有功能不变的前提下加上新的功能, 这时候就轮到装饰器出马了!  
或者, 还是以游戏为例, 你想打赢眼前这个 boss, 除了打怪练级外(升级重构原来的代码), 获得更厉害的装备(使用装饰器!)不也是很好的策略吗(尤其是假设你装备槽无限的时候[毕竟装饰器可没有数量限制], 想想后期出 100 把多兰剑?)
