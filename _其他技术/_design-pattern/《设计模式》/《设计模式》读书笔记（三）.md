# 《设计模式》读书笔记（三）

> 关键词: 设计模式, 读书笔记

目录:

- 适配器模式
- 外观模式

## 适配器模式

你在外国, 看着别的形状的电源插口, 再看着你手上两条杠的充电器插头, 你陷入了沉思. 怎么让两个不兼容的接口互相调用呢? 你需要一个适配器!

适配器是一个 超类/实现了一方接口的类, 他套在用户的外面(有点像装饰器, 但是主要目的不同), 将用户的接口**伪装成**所需的接口.

适配器分为 类适配器和对象适配器, 前者是一个超类, 好处在于可以抽取子类共同部分, 简化代码. 后者是一个实现了接口的对象, 好处在于有更大的灵活性

> 用于让接口转化成需求的样式

## 外观模式

外观模式是指, 面对一个复杂的系统, 操作他需要相当多的细节, 为了简化操作, 我们提供一个简单而统一的接口(并非关键词 interface 指定的那个接口, 而是抽象意义的接口)来避免用户和这些细节打交道. 更简洁的外观简化了用户的操作, 同时他又没将底层的细节封死, 你同样可以自由的操纵底层细节(如果你真的想这么做)

最典型的最常见的就是各个库. 他们提供了简单的访问途径, 但是你也可以深入其中进行自定义的改动.

> 用于简化接口

## 模板方法模式

面对一系列相近的算法, 与其分别在多个类里实现他们, 我们不如将相似部分抽成一个模板类, 再让子类决定各自的细节. 以 咖啡/茶为例:

| 步骤\饮品 | 咖啡       | 茶         |
| --------- | ---------- | ---------- |
| 1         | 烧开水     | 烧开水     |
| 2         | 泡咖啡     | 泡茶       |
| 3         | 装到杯子里 | 装到杯子里 |
| 4         | 加牛奶     | 什么也不加 |

我们发现 1, 3 两步是一模一样的, 而 2,3 两步差别也不大, 于是我们可以定义这样的**热饮类**:

```java
abstract class HotDrink {

    final void prepare() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    abstract void brew();
    abstract void addCondiments();

    void boilWater() {
        // ...
    }
    //...
}
```

在 HotDrink 类里我们只规定了算法的总体步骤和一些通用的方法, 而将自定义的部分留给子类实现

例如, `sort` 就是一个模板算法, 其中需要你给定一个比较大小的方法, 这个比较的方法就是用来插到算法的空槽(即模板方法)里的!

## 迭代器模式

将聚合的一群元素用迭代器封装, 使得遍历任何迭代器元素都可以用统一的接口

一个集合对象只需实现迭代器的 `next, hasNext`接口即可.

典型的如 python, js 里的 `for item in items`

## 组合模式

利用树形结构表示聚合的一群元素, 每个节点继承自相同的 node 类, 这样可以用遍历树的方法遍历这一群集合, 并且保有其父子关系

## 状态模式

### 情景

实现类似这样的类: 主类有若干动作, 还有不同的状态, 每个动作在不同的状态下都有不同的效果

这时候你可能会这么写:

    actionA:
        if stateA: ...
        else if stateB: ...
        else: ...
    actionB:
        if stateA: ...
    ...

这样写当然可以正常处理逻辑, 但是假如这时候主类又多了一种状态呢? 你就需要在各个动作里添加条件判断, 破坏了封装好的代码

### 使用设计模式

我们定义一个动作接口, 分别让不同的状态类实现这些接口, 在让主类**有一系列**状态类(若状态类想拿到主类的状态[如在切换状态时], 可以通过 getter 函数进一步降低耦合度), 这时候主类调用行为时只需要调用自己状态的行为即可, 而同时状态类也有一个主类的引用, 使得可以在自身的代码里切换主类的状态()

## 代理模式

有时候直接访问对象会有种种问题(如: 需要安全权限, 对象在远程主机上, 访问对象开销很大等), 这时候我们可以给这个对象一个代理, 简化访问操作(如封装网络请求, 设置缓存等, 控制访问等)

1. 和适配器模式的区别: 适配器模式主要改变所考虑对象的接口, 而代理模式不能改变代理类的接口
2. 和装饰器模式的区别: 装饰器模式为了增强功能, 而代理模式是为了以控制

> 可以配合工厂模式直接返回一个代理过的对象, 用户也无需知道这个对象是否经过了代理
