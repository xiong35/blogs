# 《设计模式》读书笔记（二）

> 关键词: 设计模式, 读书笔记

## 工厂模式

### 简单工厂模式

这个真的很简单... 说白了就是, 当你在编写这样的代码时: [需要创建一些实例, 这些实例属于若干种类], 与其在主代码里进行判断, 不如把构造这些实例的代码抽成一个函数, 根据参数来调整返回的实例

### 工厂方法模式

和 _简单工厂_ 模式的区别在于以下几点

- 简单工厂将创建实例的过程放在了一个特定的静态类方法(在非 java 的语言里, 即函数)中, 而工厂方法模式将创建实例的过程放在了自己的抽象方法里, 待不同的子类分别实现
- 简单工厂的实例化方法是单一的, 不可变的(虽然内部会根据参数的不同来进行一些选择, 但是大致的类别还是单一的[否则就不是一个合适的封装了]), 而工厂方法的实例化方法可以由子类自定义
- 简单工厂只进行了一层封装, 工厂方法有两层封装, 耦合度更低
- 每创造一个抽象工厂, 意味着要额外创造一系列由他生产的类, 增大了代码量

> 依赖接口编程: 注意到这里的 creator 超类不需要知道工厂究竟返回了哪个产品, 只用知道这是一个实现了特定接口的, 自己厂里的, 合乎一定规范的产品就行了, 可以不用考虑实例, 只考虑接口而编写代码

### 抽象工厂模式

定义一个接口, 这个接口里的若干函数都是 _工厂方法_.  
工厂模式是把**一系列**要制造的东西组合在了一起, 分别实现制造的工厂

### 三者比较

| \|简单工厂     | 工厂方法                                | 抽象工厂                                                                |
| -------------- | --------------------------------------- | ----------------------------------------------------------------------- |
| 是什么         | 函数/**静态方法**                       | Obj 的一个**抽象方法**                                                  | 独立于 Obj 的**接口** |
| 制造产品的时机 | 在**父**类运行时                        | 在**子**类运行时                                                        | 在**子**类运行时 |
| 适用情况       | 要在 a1, a2, a3,...等实例中选一个制造时 | 要在 a11, a12...a21, a22...中选一个分支(如 a2 系列), 再选具体实例制造时 | 在 (a1,b1,c1...), (a2, b2, c2...)...中选**一组**制造时 |

## 单例模式

有些地方只需要类的一个实例(如只需要一个线程池, 一个 vuex 实例), 但是一个普通的类是可以被实例化多次的, 你不能指望靠口头约定来限制多于一次的实例化. 这时候就需要单例模式了

```java
public class SingleObject {

   //创建 SingleObject 的一个对象
    private static SingleObject instance;

   //让构造函数为 private，这样该类就不会被实例化
    private SingleObject() {}

   //用静态方法获取唯一可用的对象
    public static SingleObject getInstance() {
        if (instance == null) {
            instance = new SingleObject();   //problem
        }
      return instance;
    }
   //其他代码
}
```

以上是简单的单例模式, 他已经足以说明单例模式的思想了, 但是存在线程安全问题. 即: 如果有多个线程同时进入了注释了 problem 的那一行, 就会产生多个实例.  
解决方法如下:

```java
public class SingleObject {

   //volatile 关键字使得每次改变这个对象都会立即通知所有线程
    private volatile static SingleObject instance;

    private SingleObject() {}

    public static SingleObject getInstance() {
        if (instance == null) {
            //在初始化的时候暂停别的线程, 避免冲突
            synchronized (SingleObject.class) {
                instance = new SingleObject();
            }
        }
      return instance;
    }
   //其他代码
}
```

## 命令模式

### 场景

你有一个万能遥控器, 它可以控制各种家电的开关(尽管家电开关的方法各不相同)  
当然, 你可以针对每个家电设计开和关的动作, 但是万一新买了家电呢? 又要再写两个函数吗? 这样的维护十分麻烦.
为了实现这个目的, 并且为了让遥控器兼容更多未来的家具, 可以使用命令模式

### 介绍

命令模式有以下三大主体:

1. 发令者(invoker 对象, 在这里就是遥控器)
2. 命令(command 接口, 在这里是 开/关 的指令)
3. 接收者(receiver 对象, 这里是各种家电)

不同的 receiver 有不同的方法  
invoker **有一个** command 实例, 还有 `setCommand` 的方法来变换这个实例  
command 接口有 `execute` 方法, 实现 command 接口的实例**有一个** receiver 实例. 每个 receiver 对应一组 command 实例, `excecute` 会调用该 receiver 特有的 开/关 方法

当真正执行时, 只需要让 invoker 设置成正确的实现了 command 接口的实例, 调用它的 `execute` 方法, 这个方法就会调用正确的 receiver 对象的方法了. 而此时 invoker 并不需要知道自己调用了哪个 receiver 的方法吗他只是发出来 excecute 的**命令**而已

命令模式可以将运算块打包, 并进行记录/传递等操作.
