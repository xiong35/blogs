

# 记一道杀马的c语言题目

反正最后写出来的程序大概是这样的↓

![长达100+字符的一行代码](https://s1.xx1x.com/2020/06/15/N9g6tx.md.png)

## 题目

将输入的3个整数按从大到小的顺序输出

但是!  
不能用 if / while / for / ? / goto 等操作  
不能使用除了最开始给的三个数之外的其他变量  
不能使用 printf / scanf 以外的任何函数  
不能在表达式里赋值, 如```(x<y)||(x=y);```, 赋值语句只能单独成一句  
不能在表达式里, 如```(x<y)||printf("hhhh");```, printf只能单独成一句, 但是printf里面可以包含计算, 如```printf("%d", x + y);```

## 思路

首先, 题目条件封死了所有流程控制的可能, 而要求我们总能按要求输出, 说明**存在某种通用的输出方法**

这种方法显然不能是形如```print("%d %d %d", x, y, z);```之类的, 因为没有办法进行流程控制, 你怎么知道要用怎样的顺序输出?  
如果能将 x 设为最大的数, 说明已经有方法能找到最大数了, 同理也可以找到最小数, 用三数之和减去最大和最小即可得到中等大的数, 但是既然已经得到这样的数了, 何不直接在 printf 中输出呢! 而且排除了流程控制后似乎只有这种方法来实现排序了

问题来到了**怎么找出三个数中最大的数**, 而如果能**找到两个数中较大的那个**, 就可以再用同样的方法找到三个数中最大的

如果用逻辑运算, 由于不能在逻辑运算中赋值, 最后只能得到 0 / 1 的真假值, 无法满足要求  
用加减运算同样无法得到结果, 加减运算是对称的, 没办法做区分

只剩下一种可能: **位运算**

## 题解

```-(x<y)```: 得到的是 0 / -1, 写成二进制就是全0或全1  
```x^(x^y)```: 得到y  
```x^(0)```: 得到x

综合上式, 写出这样的式子: ```x^((x^y) & -(x<y))```  
如果x小, ```-(x<y)```得到全1, ```x^y & 全1```得到```x^y```, 整个式子的值就是y, 也就是较大数.  
如果x大, ```-(x<y)```得到全0, ```x^y & 全0```得到0, 整个式子的值就是x, 同样是较大数.  

同理写出 ```MIN(x, y) = y^((x^y) & -(x<y))```

这样就有了比较两数大小的算法, 再进行套娃就可以得到比较任意多个数的算法了!

最终程序如下:

```c
#include<stdio.h>

int main(void)
{
    int x, y, z;

    scanf("%d", &x);
    scanf("%d", &y);
    scanf("%d", &z);

    printf("%d ", z^((z^(x^((x^y)&-(x<y))))&-(z<(x^((x^y)&-(x<y))))));

    printf("%d ", x+y+z - 
                (z^((z^(x^((x^y)&-(x<y))))&-(z<(x^((x^y)&-(x<y)))))) - 
                (z^(((x^((y^x)&-(y<x)))^z)&-((x^((y^x)&-(y<x)))<z))) );

    printf("%d ", z^(((x^((y^x)&-(y<x)))^z)&-((x^((y^x)&-(y<x)))<z)));

    return 0;
}
```

淦!