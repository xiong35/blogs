# Graph Query Language(GQL)

> 关键词: 前端杂记, 后端杂记

## 为啥要用 GQL

### rest api 的痛点

设想这样一个场景: 你在做一个电商网站, 个人主页界面需要以下信息:

- 用户信息
  - 昵称
  - 头像
- 推荐商品
  - 图片
  - 描述
  - id
- 收藏夹
  - 收藏数量

收藏夹界面需要以下信息:

- 收藏夹
  - 收藏数量
  - 收藏商品
    - 图片
    - 描述
    - id
    - 收藏时间

个人主页里你需要请求 3 个接口(用户信息, 商品, 收藏夹), 收藏夹界面同样需要请求收藏夹接口, 问题来了, 你怎么请求收藏夹里商品数量这个信息?

- 直接调用收藏夹的接口: 会获取很多不必要的信息, 占用带宽
- 利用收藏夹的接口, 但是传入一个参数, 代表是否需要具体的商品: 增加逻辑判断, 当接口复杂起来前后端都不好维护
- 再开一个新的接口: 接口更多, 变得不好维护

这 3 种方案都不够好. 此外, 收藏夹和推荐商品都用到了商品信息的接口, 但是可能要获取的字段不一样(比如收藏夹里要多一个收藏时间), 同样带来了维护问题

当接口间互相依赖, 甚至有调用的先后关系时, 往往形成的不是一个平行的结构(即 rest 接口最常见的结构), 而是树甚至是图的结构. 诚然可以通过新增特定的专门的 rest 接口或者通过增加条件判断来凑, 但是都有不好维护的问题, rest 接口适合解决**一个资源的问题**, 而非一组相互依赖的资源

### 用 GQL 解决这个痛点

gql 就是专门用来处理相互依赖的图状接口的.

先看一个例子

### github 的 gql api

搬上来以前的一篇博客, 里面有详细的介绍

[xiong35 github api 的使用](http://www.xiong35.cn/blog2.0/articles/blog/88)

### Apollo GQL 库

官方文档(英文版): [apollo gql 文档](https://www.apollographql.com/docs/tutorial/introduction)

这个库前端可适配多种框架, 后端使用 node, 核心在于解析你的 gql 语句, 判断出你具体的查询, 然后需要后端实现对某个字段具体查询的返回结果(可以是 api 请求, 也可以是查数据库等). 他做的工作实际上是将复杂度 gql 请求拆解为独立的, 不可再分的基本字段, 最后将这些字段根据查询语句进行组装而返回

此外 apollo 还有智能的类型判断, 全局状态, mixin, 接口, 缓存等功能, 官方教程也相当到位, 我觉得很赞

## 小结

实际上 gql 并没有减少 api 数量, 甚至可能增加了(每个接口都被拆分成了最小的单元, 数量上可能就增加了), 也没有降低查询带宽, 甚至可能增加了(多个字段有先后依赖关系时可能要发送多次请求), 但是, 它带来的好处在于简化了后端真正的接口(每个接口都只用进行最简单的查询), 同时提高了了代码维护性(查询需求变动时仅需改变 gql 语句)

我觉得有一句话说的很对: 任何计算机问题都可以通过增加一个中间层来解决  
gql 就是这么一个中间层, 解耦了前端查询和后端逻辑, 虽然性能不一定得到了提升, 但是代码的鲁棒性却是大大增加

话说回来, 前端后端都可以来写这个 gql 的框架, 具体谁来写可能就是队内地位问题了...

## 参考

- [github gql 文档](https://developer.github.com/v4/)
- [xiong35 github api 的使用](http://www.xiong35.cn/blog2.0/articles/blog/88)
- [apollo gql 文档](https://www.apollographql.com/docs/tutorial/introduction)
